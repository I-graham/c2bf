WHITESPACE = _{ " " | "\t" | NEWLINE }

CONSTANT = @{ (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT+ | ASCII_DIGIT) }

IDENTIFIER = @{
  ASCII_ALPHANUMERIC+
}

primary_expr =
	{ CONSTANT
	| IDENTIFIER
	| "(" ~ expr ~ ")"
 	| "(" ~ type_name ~ ")" ~ "{" ~ initializer_list ~ ","? ~ "}"
	}

postfix_expr = { primary_expr ~ postfixture* }
	postfixture = {index | call | field | pfield | inc | dec}
	index = { "[" ~ expr ~ "]" }
	call = { "(" ~ ")" | "(" ~ assign_expr ~ ("," ~ assign_expr)* ~ ")" }
	field = { "." ~ IDENTIFIER }
	pfield = { "->" ~ IDENTIFIER }
	inc = { "++" }
	dec = { "--" }
	
unary_expr =
	{ postfix_expr
	| prefix_op ~ unary_expr
	| unary_operator ~ cast_expr
	| type_size_expr
	}

prefix_op =
	{ "++"
	| "--"
	| "sizeof"
	}

type_size_expr = { "sizeof" ~ "(" ~ type_name ~ ")" }

unary_operator =
	{ "&"
	| "*"
	| "+"
	| "-"
	| "~"
	| "!"
	}

cast_expr =
	{ unary_expr
	| "(" ~ type_name ~ ")" ~ cast_expr
	}

mul_expr = { cast_expr ~ (mul_op ~ cast_expr)* }
	mul_op = { "*" | "/" | "%" }

add_expr = { mul_expr ~ (add_op ~ mul_expr)* }
	add_op = { "+" | "-" }
	
shift_expr = { add_expr ~ (shift_op ~ add_expr)* }
	shift_op = { "<<" | ">>" }

rel_expr = { shift_expr ~ (rel_op ~ shift_expr)* }
	rel_op = { "<" | ">" | "<=" | ">=" }

eq_expr = {rel_expr ~ (eq_op ~ rel_expr)* }
	eq_op = { "==" | "!=" }
	
and_expr = {eq_expr ~ (and_op ~ eq_expr)* }
	and_op = {"&"}

xor_expr = {and_expr | (xor_op ~ and_expr)* }
	xor_op = {"^"}

ior_expr = {xor_expr ~ (ior_op ~ xor_expr)* }
	ior_op = {"|"}

land_expr = {ior_expr ~ (land_op ~ ior_expr)*}
	land_op = {"&&"}

lor_expr = {land_expr ~ (lor_op ~ land_expr)*}
	lor_op = {"||"}

conditional_expr =
	{ lor_expr ~ "?" ~ expr ~ "{" ~ conditional_expr
	| lor_expr
 	} 	

assign_expr =
	{ unary_expr ~ assign_op ~ assign_expr
	| conditional_expr
	}

assign_op =
	{ "="
	| "*="
	| "/="
	| "%="
	| "+="
	| "-="
	| "<<="
	| ">>="
	| "&="
	| "|="
	| "^="
	}

expr = {assign_expr ~ ("," ~ assign_expr)* }

const_expr =
	{ conditional_expr
	}

declaration =
	{ declaration_specifiers ~ ";"
	| declaration_specifiers ~ init_declarator_list ~ ";"
	}

declaration_specifiers = {(storage_class_specifier | type_specifier | type_qualifier | "inline")+}

init_declarator_list = { init_declarator ~ ("," ~ init_declarator)* }

init_declarator = { declarator ~ ("=" ~ initializer)* }

storage_class_specifier =
	{ "typedef"
	| "extern"
	| "static"
	| "auto"
	| "register"
	}

type_specifier =
	{ "void"
	| "char"
	| "short"
	| "int"
	| "long"
	| "float"
	| "double"
	| "signed"
	| "unsigned"
	| struct_or_union_specifier
	| enum_specifier
	| IDENTIFIER
	}



struct_or_union_specifier =
	{ struct_or_union ~ IDENTIFIER ~ "{" ~ struct_declaration_list ~ "}"
	| struct_or_union ~ "{" ~ struct_declaration_list ~ "}"
	| struct_or_union ~ IDENTIFIER
	}

struct_or_union =
	{ "struct"
	| "union"
	}

struct_declaration_list = { struct_declaration+ }

struct_declaration = { specifier_qualifier_list ~ struct_declarator_list ~ ";" }

specifier_qualifier_list = { (type_specifier | type_qualifier)+}

struct_declarator_list = { struct_declarator ~ ("," ~ struct_declarator)* }

struct_declarator =
	{ ":" ~ const_expr
	| declarator ~ ":" ~ const_expr
	| declarator
	}

enum_specifier =
	{ "enum" ~ "{" ~ enumerator_list ~ ","? ~ "}"
	| "enum" ~ IDENTIFIER ~ "{" ~ enumerator_list ~ ","? ~ "}"
	| "enum" ~ IDENTIFIER
	}

enumerator_list = { enumerator ~ ("," ~ enumerator)* }

enumerator =
	{ IDENTIFIER
	| IDENTIFIER ~ "=" ~ const_expr
	}

type_qualifier =
	{ "const"
	| "restrict"
	| "volatile"
	}

declarator =
	{ pointer ~ direct_declarator
	| direct_declarator
	}

direct_declarator = { (IDENTIFIER | "(" ~ declarator ~ ")") ~ ( sized | brackets | params | typequal )* }
	brackets = { "[" ~ "*"? ~ "]" }
	params   = { "(" ~ ( parameter_list )? ~ ")"}
	typequal =  { "[" ~ type_qualifier_list ~ "*"? ~ "]" }
	sized    =
		{ "[" ~ type_qualifier ~ "static" ~ assign_expr ~ "]" 
		| "[" ~ "static" ~ type_qualifier ~ assign_expr ~ "]"
		| "[" ~ type_qualifier ~ assign_expr ~ "]"
		| "[" ~ assign_expr ~ "]"
		}

pointer = { deref ~ (type_qualifier | deref)* }
	deref = {"*"}

type_qualifier_list = { type_qualifier+ }

parameter_type_list =
	{ parameter_list ~ "," ~ "..."
	| parameter_list
	}

parameter_list = { parameter_declaration ~ ("," ~ parameter_declaration)* }

parameter_declaration =
	{ named_param
	| type_name
	}

named_param = { specifier_qualifier_list ~ declarator }

identifier_list = { IDENTIFIER ~ ("," ~ IDENTIFIER)* }

type_name =
	{ specifier_qualifier_list ~ abstract_declarator
	| specifier_qualifier_list
	}

abstract_declarator =
	{ pointer ~ direct_abstract_declarator
	| pointer
	| direct_abstract_declarator
	}

direct_abstract_declarator =
	{ "(" ~ abstract_declarator ~ ")" ~ (brackets | const_sized | params)*
	| (brackets | const_sized | params)+
	}

const_sized = {"[" ~ const_expr ~ "]"}

initializer =
	{ "{" ~ initializer_list ~ ","? ~ "}"
	| assign_expr
	}

initializer_list = { initializer ~ ("," ~ initializer)* }

statement =
	{ labeled_statement
	| compound_statement
	| expr_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	}

labeled_statement =
	{ IDENTIFIER ~ ":" ~ statement
	| "case" ~ ":" ~ const_expr ~ ":" ~ statement
	| "default" ~ ":" ~ statement
	}

compound_statement = { "{" ~ (declaration | statement)* ~ "}" }

statement_list = { statement+ }

expr_statement = { expr? ~ ";" }

selection_statement =
	{ "if" ~ "(" ~ expr ~ ")" ~ statement
	| "if" ~ "(" ~ expr ~ ")" ~ statement ~ "else" ~ statement
	| "switch" ~ "(" ~ expr ~ ")" ~ statement
	}

iteration_statement = { while | do_while | for_while }

while = { "while" ~ "(" ~ expr ~ ")" ~ statement }
do_while = {"do" ~ statement ~ "while" ~ "(" ~ expr ~ ")" ~ ";" }
for_while = { "for" ~ "(" ~ (expr_statement | declaration) ~ expr_statement ~ expr? ~ ")" ~ statement }

jump_statement =
	{ "goto" ~ IDENTIFIER ~ ";"
	| "continue" ~ ";"
	| "break" ~ ";"
	| "return" ~ ";"
	| "return" ~ expr ~ ";"
	}

translation_unit = { external_declaration+ }

external_declaration =
	{ function_definition
	| declaration
	}

function_definition = { declaration_specifiers ~ declarator ~ compound_statement }
